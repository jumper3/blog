<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山哥的地盘</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://jumper3.github.io/blog/"/>
  <updated>2017-12-26T09:06:07.576Z</updated>
  <id>https://jumper3.github.io/blog/</id>
  
  <author>
    <name>Jonathan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百词斩三个月小记</title>
    <link href="https://jumper3.github.io/blog/2017/12/26/%E7%99%BE%E8%AF%8D%E6%96%A9%E4%B8%89%E4%B8%AA%E6%9C%88/"/>
    <id>https://jumper3.github.io/blog/2017/12/26/百词斩三个月/</id>
    <published>2017-12-26T08:07:59.000Z</published>
    <updated>2017-12-26T09:06:07.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="三个月期间做过哪些项目"><a href="#三个月期间做过哪些项目" class="headerlink" title="三个月期间做过哪些项目"></a>三个月期间做过哪些项目</h4><ol><li><p>系统思维课-视频中心</p></li><li><p>系统思维课-小书单</p></li><li><p>百词斩阅读者-阅读者</p><p>​</p></li></ol><h4 id="使用过哪些技术"><a href="#使用过哪些技术" class="headerlink" title="使用过哪些技术"></a>使用过哪些技术</h4><h5 id="视频中心"><a href="#视频中心" class="headerlink" title="视频中心"></a>视频中心</h5><table><thead><tr><th>技术</th><th>用途</th></tr></thead><tbody><tr><td>Tornado</td><td>利用模版功能渲染页面</td></tr><tr><td>Redis</td><td>用户信息的key-value储存</td></tr><tr><td>Bootstrap</td><td>标题栏、按钮</td></tr><tr><td>Swiper</td><td>首页轮播图，支持触控，为移动设备优化</td></tr><tr><td>Google Analytics</td><td>网站流量分析、用户统计</td></tr><tr><td>Terminal</td><td>Linux常用指令、SSH</td></tr></tbody></table><h5 id="小书单"><a href="#小书单" class="headerlink" title="小书单"></a>小书单</h5><table><thead><tr><th>技术</th><th>用途</th></tr></thead><tbody><tr><td>Tornado</td><td>小程序后端框架</td></tr><tr><td>MySQL</td><td>小程序主力数据库</td></tr><tr><td>小程序API</td><td>完成小程序的数据处理及交互</td></tr><tr><td>小程序框架</td><td>类Vue的MVVM框架，用于模版渲染</td></tr><tr><td>ES6</td><td>使用了迭代器、模块化、块级绑定、字符串模版等新特性</td></tr></tbody></table><h5 id="阅读者"><a href="#阅读者" class="headerlink" title="阅读者"></a>阅读者</h5><table><thead><tr><th>技术</th><th>用途</th></tr></thead><tbody><tr><td>Vue.js</td><td>阅读者前端框架、组件化</td></tr><tr><td>Vue-router</td><td>页面路由</td></tr><tr><td>Animated.css</td><td>通过第三方CSS库优化交互</td></tr><tr><td>axios</td><td>AJAX</td></tr><tr><td>jQuery</td><td>项目初期用DOM思想快速开发</td></tr><tr><td>Less</td><td>嵌套语法，scope作用域</td></tr><tr><td>Node.js-Express</td><td>亮哥主后端，我辅助，顺便了解promise</td></tr></tbody></table><h5 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h5><p>Vscode、Bitbuckets(Git)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;三个月期间做过哪些项目&quot;&gt;&lt;a href=&quot;#三个月期间做过哪些项目&quot; class=&quot;headerlink&quot; title=&quot;三个月期间做过哪些项目&quot;&gt;&lt;/a&gt;三个月期间做过哪些项目&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;系统思维课-视频中心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://jumper3.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象的深入理解 （二）</title>
    <link href="https://jumper3.github.io/blog/2017/11/02/JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://jumper3.github.io/blog/2017/11/02/JS对象的深入理解（二）/</id>
    <published>2017-11-02T09:17:00.000Z</published>
    <updated>2017-12-26T09:19:38.171Z</updated>
    
    <content type="html"><![CDATA[<p>之前提到，构造函数方法创建对象存在着<strong>方法不共享</strong>的问题，因此引申出了原型模式创建对象</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><blockquote><p> 原型模式旨在创建一个<strong>模版对象</strong>，该对象的<strong>所有属性和方法</strong>被其实例所共享。</p></blockquote><h4 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h4><p>不同于构造函数模式创建对象只能单级即成，得益于<strong>原型链</strong>的概念，原型模式可实现类似其他OOP语言的多级继承。</p><blockquote><p>原型链：一系列有<strong>继承关系</strong>的函数（对象）中[[prototype]]属性<strong>自底向上</strong>的指向</p></blockquote><p>先给一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Jonathan",</span><br><span class="line">    age: 23,</span><br><span class="line">  job: developer,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person2 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>该例子中各对象的关系如下</p><p>//</p><p>每一个函数（对象）都可以视为一个<strong>模版</strong>，向上看，该对象的[[prototype]]</p><h4 id="创建原型对象"><a href="#创建原型对象" class="headerlink" title="创建原型对象"></a>创建原型对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Jonathan",</span><br><span class="line">    age: 23,</span><br><span class="line">  job: developer,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">//"Jonathan"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">//"Jonathan"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>要点</p><ol><li>先命名一个空函数</li><li>用对象字面量方式，为该函数的.prototype属性添加原型属性及方法</li><li>为了constructor属性的正确指向，应先把constructor指向该对象</li></ol><h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><p>由于众多实例共享原型的属性，因此改变其中某个实例的属性会影响到全局，造成<strong>属性污染</strong>，例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    friends : ["Shelby", "Court"],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>可见，person1的friends属性污染了person2的friends属性。为避免这种情况，引入组合构造函数与原型模式。</p><h3 id="组合使用构造函数与原型模式"><a href="#组合使用构造函数与原型模式" class="headerlink" title="组合使用构造函数与原型模式"></a>组合使用构造函数与原型模式</h3><p>单一使用原型对象的问题在于<strong>所有属性皆共享</strong>，若不想共享某属性，则可放入构造函数中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Boy next door"</span>, <span class="string">"Deep dark fantasy"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前提到，构造函数方法创建对象存在着&lt;strong&gt;方法不共享&lt;/strong&gt;的问题，因此引申出了原型模式创建对象&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://jumper3.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象的深入理解 （一）</title>
    <link href="https://jumper3.github.io/blog/2017/09/19/JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jumper3.github.io/blog/2017/09/19/JS对象的深入理解（一）/</id>
    <published>2017-09-19T09:07:59.000Z</published>
    <updated>2017-12-26T09:19:24.501Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对象，一种数据类型。对象是<strong>属性(变量)</strong>和<strong>方法(函数)</strong>结合在一起的数据实体</p></blockquote><p>对象的出现，就是为了解决<strong>封装</strong>的问题。可以将许多属性与方法封装在一个对象里，方便调用，也符合人的思考方式。</p><h3 id="JavaScript中创建对象的基本方法"><a href="#JavaScript中创建对象的基本方法" class="headerlink" title="JavaScript中创建对象的基本方法"></a>JavaScript中创建对象的基本方法</h3><ol><li><p>创建Object实例，再添加属性和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">    person.name = &quot;Jonathan&quot;;</span><br><span class="line">    person.age = 23;</span><br><span class="line">    person.job = &quot;Developer&quot;;</span><br><span class="line">    person.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量方法<br>由于上述写法繁琐，故出现了对象字面量方法创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Jonathan&quot;,</span><br><span class="line">    age: 23,</span><br><span class="line">    job: &quot;Developer&quot;,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person.name); //Jonathan</span><br><span class="line">person.sayName(); //Jonathan</span><br></pre></td></tr></table></figure></li></ol><p>这样一来，就把属性和方法封装进了一个对象中，方便调用。</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>如果要创建许多对象，传统方法存在以下问题</p><ul><li>对象名太多，容易搞重复</li><li>新建一个对象就要全部重写属性和方法，过于复杂</li><li>无法发挥JavaScript的面向对象优势（继承）</li></ul><p>由于JavaScript本身没有类的概念，因此诞生了构造函数模式来创建对象，该方法<strong>利用函数创建对象</strong>。由于函数本身也是对象，因此可以这么操作。<br>构造函数创建对象的方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">                       console.log(this.name);</span><br><span class="line">                   &#125;;    </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure></p><p>要点：</p><ol><li>构造函数命名应以<strong>大写字母开头</strong>（约定俗成的规矩）</li><li>构造函数本身也是函数，只不过是用来创建对象的</li><li>要创建对象的实例，必须要用<strong>new</strong>操作符，否则跟调用函数无异。</li><li>任何函数，只要通过new操作符来调用，它就可以作为构造函数。</li></ol><p>至此，一个Person对象的创建就完成了，它有以下优点：</p><ul><li>新建对象只用给函数提供参数，简化了创建。</li><li>有了实例的概念，如Person1就是Person的实例。无形之中给对象归了类。</li><li>更好的体现了<strong>封装</strong>，创建对象只用给参数，不用关心对象内部细节。</li></ul><p><strong>但</strong>用构造函数模式的方法创建对象并不是完美的，它存在以下问题，即：<br><strong>每个方法（对象内置函数）都要在实例上重新创建一遍</strong><br>构造函数也可以用以下方法定义，方便我们发现问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = new Function(console.log(this.name));</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName == person2sayName); //false</span><br></pre></td></tr></table></figure><p>在新建对象person1和person2时，分别新建了两个不同的方法person1.sayName()和person2.sayName()。<br>但这很没有必要，只需要公用一个sayName()方法就好了。为了解决上述问题，诞生了原型模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对象，一种数据类型。对象是&lt;strong&gt;属性(变量)&lt;/strong&gt;和&lt;strong&gt;方法(函数)&lt;/strong&gt;结合在一起的数据实体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对象的出现，就是为了解决&lt;strong&gt;封装&lt;/strong&gt;的
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://jumper3.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JSON初探</title>
    <link href="https://jumper3.github.io/blog/2017/09/09/JSON%E5%88%9D%E6%8E%A2/"/>
    <id>https://jumper3.github.io/blog/2017/09/09/JSON初探/</id>
    <published>2017-09-09T04:00:00.000Z</published>
    <updated>2017-12-26T09:25:50.391Z</updated>
    
    <content type="html"><![CDATA[<p>JSON是什么？</p><blockquote><ul><li>JSON是一种<strong>数据格式</strong>，不是一种编程语言。</li><li>JSON<strong>不属于Javascript</strong>，尽管有相同的语法形式</li><li>并不只是Javascript，很多语言都可以使用JSON交换数据</li></ul></blockquote><hr><h2 id="JSON的语法"><a href="#JSON的语法" class="headerlink" title="JSON的语法"></a>JSON的语法</h2><h3 id="JSON可以表示的值"><a href="#JSON可以表示的值" class="headerlink" title="JSON可以表示的值"></a>JSON可以表示的值</h3><ol><li>简单值<br>包括字符串、数值、布尔值、null</li><li>对象<br>包括简单值或对象。为<strong>不同类型的无序键值对集合</strong></li><li>数组<br>包括简单值、对象、数组。为<strong>相同类型的有序数据集合</strong></li></ol><h3 id="JSON对象的构成方式"><a href="#JSON对象的构成方式" class="headerlink" title="JSON对象的构成方式"></a>JSON对象的构成方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;Jonathan&quot;,</span><br><span class="line">    &quot;age&quot;:23,</span><br><span class="line">    &quot;job&quot;:&quot;developer&quot;,</span><br><span class="line">    &quot;school&quot;: &#123;</span><br><span class="line">        &quot;schName&quot;:&quot;CDUT&quot;,</span><br><span class="line">        &quot;location&quot;: &quot;Chenghua CD&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要点：</p><ol><li>没有声明变量（不用在前面加var）</li><li>没有末尾的分号</li><li>对象的属性与属性名<strong>必须加双引号</strong></li></ol><h3 id="JSON数组的构成方式"><a href="#JSON数组的构成方式" class="headerlink" title="JSON数组的构成方式"></a>JSON数组的构成方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">    &quot;age&quot;: 24,</span><br><span class="line">    &quot;job&quot;: &quot;writer&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Bob&quot;,</span><br><span class="line">    &quot;age&quot;: 21,</span><br><span class="line">    &quot;job&quot;: &quot;student&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;:&quot;Jonathan&quot;,</span><br><span class="line">    &quot;age&quot;:23,</span><br><span class="line">    &quot;job&quot;:&quot;developer&quot;,</span><br><span class="line">    &quot;school&quot;: &#123;</span><br><span class="line">        &quot;schName&quot;:&quot;CDUT&quot;,</span><br><span class="line">        &quot;location&quot;: &quot;Chenghua CD&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>要点：</p><ol><li>整个数组用[]包裹</li><li>各元素用逗号,隔开</li><li>对象表示法同上</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSON是什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;JSON是一种&lt;strong&gt;数据格式&lt;/strong&gt;，不是一种编程语言。&lt;/li&gt;
&lt;li&gt;JSON&lt;strong&gt;不属于Javascript&lt;/strong&gt;，尽管有相同的语法形式&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="JSON" scheme="https://jumper3.github.io/blog/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>HTML语义化</title>
    <link href="https://jumper3.github.io/blog/2017/08/28/HTML%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>https://jumper3.github.io/blog/2017/08/28/HTML语义化/</id>
    <published>2017-08-28T09:17:00.000Z</published>
    <updated>2017-12-26T09:23:06.402Z</updated>
    
    <content type="html"><![CDATA[<p>###何为HTML语义化<br>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。</p><p>###为什么要语义化？</p><ul><li>有利于SEO（搜索引擎优化），有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重。</li><li>语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构</li><li>方便其他设备的解析</li><li>便于团队开发和维护</li></ul><p>###应该注意什么？</p><ul><li>尽可能少的使用无语义的标签div和span；</li><li>在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li><li>不要使用纯样式标签，如：b、font、u等，改用css设置。</li><li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li><li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li><li>表单域要用fieldset标签包起来，并用legend标签说明表单的用途；</li><li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###何为HTML语义化&lt;br&gt;语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。&lt;/p&gt;
&lt;p&gt;###为什么要语义化？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有利于SEO（搜索引擎优化），有
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://jumper3.github.io/blog/tags/HTML/"/>
    
  </entry>
  
</feed>
