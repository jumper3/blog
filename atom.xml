<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷吃兔</title>
  
  <subtitle>大家好，我是来自自贡的冷吃兔，我给大家表演一个吐粘痰</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://jumper3.github.io/blog/"/>
  <updated>2017-12-27T09:01:24.859Z</updated>
  <id>https://jumper3.github.io/blog/</id>
  
  <author>
    <name>Jonathan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百词斩三个月小记</title>
    <link href="https://jumper3.github.io/blog/2017/12/26/%E7%99%BE%E8%AF%8D%E6%96%A9%E4%B8%89%E4%B8%AA%E6%9C%88/"/>
    <id>https://jumper3.github.io/blog/2017/12/26/百词斩三个月/</id>
    <published>2017-12-26T08:07:59.000Z</published>
    <updated>2017-12-27T09:01:24.859Z</updated>
    
    <content type="html"><![CDATA[<h4 id="三个月期间做过哪些项目"><a href="#三个月期间做过哪些项目" class="headerlink" title="三个月期间做过哪些项目"></a>三个月期间做过哪些项目</h4><ol><li><p>系统思维课-视频中心</p></li><li><p>系统思维课-小书单</p></li><li><p>百词斩阅读者-阅读者</p><p>​</p></li></ol><h4 id="使用过哪些技术"><a href="#使用过哪些技术" class="headerlink" title="使用过哪些技术"></a>使用过哪些技术</h4><h5 id="视频中心"><a href="#视频中心" class="headerlink" title="视频中心"></a>视频中心</h5><table><thead><tr><th>技术</th><th>用途</th></tr></thead><tbody><tr><td>Tornado</td><td>利用模版功能渲染页面</td></tr><tr><td>Redis</td><td>用户信息的key-value储存</td></tr><tr><td>Bootstrap</td><td>标题栏、按钮、分页Tab</td></tr><tr><td>Swiper</td><td>首页轮播图，支持触控，为移动设备优化</td></tr><tr><td>Google Analytics</td><td>网站流量分析、用户统计</td></tr><tr><td>Terminal</td><td>Linux常用指令、SSH</td></tr></tbody></table><h5 id="小书单"><a href="#小书单" class="headerlink" title="小书单"></a>小书单</h5><table><thead><tr><th>技术</th><th>用途</th></tr></thead><tbody><tr><td>Tornado</td><td>小程序后端框架</td></tr><tr><td>MySQL</td><td>小程序主力数据库</td></tr><tr><td>小程序API</td><td>完成小程序的数据处理及交互</td></tr><tr><td>小程序框架</td><td>类Vue的MVVM框架，用于模版渲染</td></tr><tr><td>ES6</td><td>使用了迭代器、模块化、块级绑定、字符串模版等新特性</td></tr></tbody></table><h5 id="阅读者"><a href="#阅读者" class="headerlink" title="阅读者"></a>阅读者</h5><table><thead><tr><th>技术</th><th>用途</th></tr></thead><tbody><tr><td>Vue.js</td><td>阅读者前端框架、组件化</td></tr><tr><td>Vue-router</td><td>页面路由</td></tr><tr><td>Animated.css</td><td>通过第三方CSS库优化交互</td></tr><tr><td>axios</td><td>AJAX</td></tr><tr><td>jQuery</td><td>项目初期用DOM思想快速开发</td></tr><tr><td>Less</td><td>嵌套语法，scope作用域</td></tr><tr><td>Node.js-Express</td><td>亮哥主后端，我辅助，顺便了解promise</td></tr></tbody></table><h5 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h5><p>Vscode、Bitbuckets(Git)、Zeplin（一款原型制作软件，方便抠图）</p><h4 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h4><h5 id="1-视频中心"><a href="#1-视频中心" class="headerlink" title="1.视频中心"></a>1.视频中心</h5><p>视频中心位于“斩家”公众号内，内容包括百词斩内部课程系统思维课的课程视频、公司内部视频分享及课程小摘要三个栏目</p><h5 id="2-小书单"><a href="#2-小书单" class="headerlink" title="2.小书单"></a>2.小书单</h5><h5 id="3-阅读者"><a href="#3-阅读者" class="headerlink" title="3.阅读者"></a>3.阅读者</h5><h4 id="遇见过哪些糟心的事-都是怎么解决的"><a href="#遇见过哪些糟心的事-都是怎么解决的" class="headerlink" title="遇见过哪些糟心的事 / 都是怎么解决的"></a>遇见过哪些糟心的事 / 都是怎么解决的</h4><h5 id="1-Python字符串编码问题"><a href="#1-Python字符串编码问题" class="headerlink" title="1.Python字符串编码问题"></a>1.Python字符串编码问题</h5><h5 id="2-JSON的保留字符"><a href="#2-JSON的保留字符" class="headerlink" title="2. JSON的保留字符"></a>2. JSON的保留字符</h5><h5 id="3-PDF在网页上的显示"><a href="#3-PDF在网页上的显示" class="headerlink" title="3.PDF在网页上的显示"></a>3.PDF在网页上的显示</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;三个月期间做过哪些项目&quot;&gt;&lt;a href=&quot;#三个月期间做过哪些项目&quot; class=&quot;headerlink&quot; title=&quot;三个月期间做过哪些项目&quot;&gt;&lt;/a&gt;三个月期间做过哪些项目&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;系统思维课-视频中心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://jumper3.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>删除数组中的指定元素</title>
    <link href="https://jumper3.github.io/blog/2017/12/02/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0/"/>
    <id>https://jumper3.github.io/blog/2017/12/02/删除数组中的指定元素/</id>
    <published>2017-12-02T10:17:00.000Z</published>
    <updated>2017-12-27T02:55:04.221Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript的数组中默认不支持删除指定元素的操作，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let book_id = [1,2,3,4]</span><br><span class="line">book_id.delete(4) //错误，JS数组没有该方法</span><br></pre></td></tr></table></figure></p><p>因此，解决的办法有</p><ul><li>使用集合Set<br>ES6中新加入了集合类型Set()，因为集合本身支持add(),delete(),remove()，forEach()等操作，因此可以直接将Array()转化为Set()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let book_id = new Set([1,2,3,4])</span><br><span class="line">book_id.delete(4)</span><br><span class="line">console.log(book_id)  //Set &#123; 1, 2, 3 &#125;</span><br></pre></td></tr></table></figure></li></ul><p>但要注意到，Set()本身的限制</p><blockquote><p>Set是一种<strong>无重复值的有序列表</strong>，允许对它包含的数据进行快速访问，从而增加了一个追踪离散值的更有效方式                                                    </p></blockquote><p>因此，如果本身要操作的数据不符合Set()的要求，则要用到ES5原生方法</p><ul><li>使用indexOf()<br>其实是通过indexOf()找到要删除元素在数组中的索引，然后用splice()删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let book_name = [&apos;1984&apos;,&apos;动物庄园&apos;,&apos;乌合之众&apos;]</span><br><span class="line">let i = book_name.indexOf(&apos;动物庄园&apos;)</span><br><span class="line">book_name.splice(i,1)</span><br><span class="line">console.log(book_name)  //[ &apos;1984&apos;, &apos;乌合之众&apos; ]</span><br></pre></td></tr></table></figure></li></ul><p>搞定！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript的数组中默认不支持删除指定元素的操作，如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://jumper3.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象的深入理解 （二）</title>
    <link href="https://jumper3.github.io/blog/2017/11/02/JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://jumper3.github.io/blog/2017/11/02/JS对象的深入理解（二）/</id>
    <published>2017-11-02T09:17:00.000Z</published>
    <updated>2017-12-26T09:19:38.171Z</updated>
    
    <content type="html"><![CDATA[<p>之前提到，构造函数方法创建对象存在着<strong>方法不共享</strong>的问题，因此引申出了原型模式创建对象</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><blockquote><p> 原型模式旨在创建一个<strong>模版对象</strong>，该对象的<strong>所有属性和方法</strong>被其实例所共享。</p></blockquote><h4 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h4><p>不同于构造函数模式创建对象只能单级即成，得益于<strong>原型链</strong>的概念，原型模式可实现类似其他OOP语言的多级继承。</p><blockquote><p>原型链：一系列有<strong>继承关系</strong>的函数（对象）中[[prototype]]属性<strong>自底向上</strong>的指向</p></blockquote><p>先给一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Jonathan",</span><br><span class="line">    age: 23,</span><br><span class="line">  job: developer,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person2 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>该例子中各对象的关系如下</p><p>//</p><p>每一个函数（对象）都可以视为一个<strong>模版</strong>，向上看，该对象的[[prototype]]</p><h4 id="创建原型对象"><a href="#创建原型对象" class="headerlink" title="创建原型对象"></a>创建原型对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Jonathan",</span><br><span class="line">    age: 23,</span><br><span class="line">  job: developer,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">//"Jonathan"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">//"Jonathan"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>要点</p><ol><li>先命名一个空函数</li><li>用对象字面量方式，为该函数的.prototype属性添加原型属性及方法</li><li>为了constructor属性的正确指向，应先把constructor指向该对象</li></ol><h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><p>由于众多实例共享原型的属性，因此改变其中某个实例的属性会影响到全局，造成<strong>属性污染</strong>，例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    friends : ["Shelby", "Court"],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>可见，person1的friends属性污染了person2的friends属性。为避免这种情况，引入组合构造函数与原型模式。</p><h3 id="组合使用构造函数与原型模式"><a href="#组合使用构造函数与原型模式" class="headerlink" title="组合使用构造函数与原型模式"></a>组合使用构造函数与原型模式</h3><p>单一使用原型对象的问题在于<strong>所有属性皆共享</strong>，若不想共享某属性，则可放入构造函数中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Boy next door"</span>, <span class="string">"Deep dark fantasy"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前提到，构造函数方法创建对象存在着&lt;strong&gt;方法不共享&lt;/strong&gt;的问题，因此引申出了原型模式创建对象&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://jumper3.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于排序问题的思考</title>
    <link href="https://jumper3.github.io/blog/2017/09/20/%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://jumper3.github.io/blog/2017/09/20/关于排序问题的思考/</id>
    <published>2017-09-20T09:07:59.000Z</published>
    <updated>2017-12-27T03:12:01.853Z</updated>
    
    <content type="html"><![CDATA[<p>今天去面试，被问到了以下问题：</p><blockquote><p>从1000个正整数中找出最大的五个数</p></blockquote><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>思路：先生成一个含1000个数的随机数组Arr1，然后建立一个空数组Arr2，及一个变量max=0。<br>然后遍历Arr1，其中大于max的数存入数组2。便利过后，得到<strong>递增</strong>数组Arr2。<br>用slice方法取Arr2后五位即为最大五位。<br>    var Arr1 = [];<br>    for (var i = 0; i&lt;1000; i++){<br>        Arr1[i] = Math.floor(Math.random()*1000+1);<br>    }; //先生成1000个正整数</p><pre><code>var Arr2 = new Array();var max = 0;for (var i = 0; i&lt;1000; i++){    if (Arr1[i]&gt;max){        Arr2.push(Arr1[i]);        max = Arr1[i];    } };var result = Arr2.slice[-5];console.log(result);</code></pre><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(5) [982,985,993,996,998]</span><br></pre></td></tr></table></figure><p>这个算法看似能找出最大数，但是存在以下问题：<br>当Arr1为[100,999,…,1]这样的递减数列时，只能找出第一个最大数，无法将Arr2凑满。而且，面试官还问到了时间复杂度的问题，当时我并没有概念。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>为妥善解决问题，还是将Arr1数组从小到大重新排列，这样就不会受到原数据中大小次序影响。<br>因此可以采用算法学中的排序方法，如冒泡排序、选择排序、插入排序等。</p><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>算法复杂度的概念（包括时间复杂度和空间复杂度）：</p><blockquote><p><a href="http://blog.csdn.net/booirror/article/details/7707551/" target="_blank" rel="noopener">http://blog.csdn.net/booirror/article/details/7707551/</a><br><a href="http://www.jianshu.com/p/99bac69fdd97" target="_blank" rel="noopener">http://www.jianshu.com/p/99bac69fdd97</a></p></blockquote><p>排序算法的Javascript实现：</p><blockquote><p><a href="https://github.com/damonare/Sorts" target="_blank" rel="noopener">https://github.com/damonare/Sorts</a></p></blockquote><h3 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h3><p>之前解法的时间复杂度为O(n)。<br>现在采用更稳妥的，可排序的冒泡排序算法，时间复杂度为O(n*n)。代码实现如下：</p><pre><code>var Arr1 = [];for (var i = 0; i&lt;1000; i++){    Arr1[i] = Math.floor(Math.random()*1000+1);};function bubbleSort(arr) {    var len = arr.length;    for (var i = 0; i &lt; len; i++) {        for (var j = 0; j &lt; len - 1 - i; j++) {            if (arr[j] &gt; arr[j+1]) {        //相邻元素两两对比                var temp = arr[j+1];        //元素交换                arr[j+1] = arr[j];                arr[j] = temp;            }        }    }    return arr;}var Arr2 = bubbleSort(Arr1);var result = Arr2.slice(-5);console.log(result);</code></pre><p>代码运行截图：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(5) [998,999,999,1000,1000]</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>显然，实现了目的，但是算法上还可以采用时间复杂度更低的算法。</p><p>怎样才能找到尽可能优的解法呢？</p><blockquote><p>且听下回分解</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天去面试，被问到了以下问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从1000个正整数中找出最大的五个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;我的解法&quot;&gt;&lt;a href=&quot;#我的解法&quot; class=&quot;headerlink&quot; title=&quot;我的解法&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="算法" scheme="https://jumper3.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象的深入理解 （一）</title>
    <link href="https://jumper3.github.io/blog/2017/09/19/JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jumper3.github.io/blog/2017/09/19/JS对象的深入理解（一）/</id>
    <published>2017-09-19T09:07:59.000Z</published>
    <updated>2017-12-26T09:19:24.501Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对象，一种数据类型。对象是<strong>属性(变量)</strong>和<strong>方法(函数)</strong>结合在一起的数据实体</p></blockquote><p>对象的出现，就是为了解决<strong>封装</strong>的问题。可以将许多属性与方法封装在一个对象里，方便调用，也符合人的思考方式。</p><h3 id="JavaScript中创建对象的基本方法"><a href="#JavaScript中创建对象的基本方法" class="headerlink" title="JavaScript中创建对象的基本方法"></a>JavaScript中创建对象的基本方法</h3><ol><li><p>创建Object实例，再添加属性和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">    person.name = &quot;Jonathan&quot;;</span><br><span class="line">    person.age = 23;</span><br><span class="line">    person.job = &quot;Developer&quot;;</span><br><span class="line">    person.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量方法<br>由于上述写法繁琐，故出现了对象字面量方法创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Jonathan&quot;,</span><br><span class="line">    age: 23,</span><br><span class="line">    job: &quot;Developer&quot;,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person.name); //Jonathan</span><br><span class="line">person.sayName(); //Jonathan</span><br></pre></td></tr></table></figure></li></ol><p>这样一来，就把属性和方法封装进了一个对象中，方便调用。</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>如果要创建许多对象，传统方法存在以下问题</p><ul><li>对象名太多，容易搞重复</li><li>新建一个对象就要全部重写属性和方法，过于复杂</li><li>无法发挥JavaScript的面向对象优势（继承）</li></ul><p>由于JavaScript本身没有类的概念，因此诞生了构造函数模式来创建对象，该方法<strong>利用函数创建对象</strong>。由于函数本身也是对象，因此可以这么操作。<br>构造函数创建对象的方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">                       console.log(this.name);</span><br><span class="line">                   &#125;;    </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure></p><p>要点：</p><ol><li>构造函数命名应以<strong>大写字母开头</strong>（约定俗成的规矩）</li><li>构造函数本身也是函数，只不过是用来创建对象的</li><li>要创建对象的实例，必须要用<strong>new</strong>操作符，否则跟调用函数无异。</li><li>任何函数，只要通过new操作符来调用，它就可以作为构造函数。</li></ol><p>至此，一个Person对象的创建就完成了，它有以下优点：</p><ul><li>新建对象只用给函数提供参数，简化了创建。</li><li>有了实例的概念，如Person1就是Person的实例。无形之中给对象归了类。</li><li>更好的体现了<strong>封装</strong>，创建对象只用给参数，不用关心对象内部细节。</li></ul><p><strong>但</strong>用构造函数模式的方法创建对象并不是完美的，它存在以下问题，即：<br><strong>每个方法（对象内置函数）都要在实例上重新创建一遍</strong><br>构造函数也可以用以下方法定义，方便我们发现问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = new Function(console.log(this.name));</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName == person2sayName); //false</span><br></pre></td></tr></table></figure><p>在新建对象person1和person2时，分别新建了两个不同的方法person1.sayName()和person2.sayName()。<br>但这很没有必要，只需要公用一个sayName()方法就好了。为了解决上述问题，诞生了原型模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对象，一种数据类型。对象是&lt;strong&gt;属性(变量)&lt;/strong&gt;和&lt;strong&gt;方法(函数)&lt;/strong&gt;结合在一起的数据实体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对象的出现，就是为了解决&lt;strong&gt;封装&lt;/strong&gt;的
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://jumper3.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JSON初探</title>
    <link href="https://jumper3.github.io/blog/2017/09/09/JSON%E5%88%9D%E6%8E%A2/"/>
    <id>https://jumper3.github.io/blog/2017/09/09/JSON初探/</id>
    <published>2017-09-09T04:00:00.000Z</published>
    <updated>2017-12-26T09:25:50.391Z</updated>
    
    <content type="html"><![CDATA[<p>JSON是什么？</p><blockquote><ul><li>JSON是一种<strong>数据格式</strong>，不是一种编程语言。</li><li>JSON<strong>不属于Javascript</strong>，尽管有相同的语法形式</li><li>并不只是Javascript，很多语言都可以使用JSON交换数据</li></ul></blockquote><hr><h2 id="JSON的语法"><a href="#JSON的语法" class="headerlink" title="JSON的语法"></a>JSON的语法</h2><h3 id="JSON可以表示的值"><a href="#JSON可以表示的值" class="headerlink" title="JSON可以表示的值"></a>JSON可以表示的值</h3><ol><li>简单值<br>包括字符串、数值、布尔值、null</li><li>对象<br>包括简单值或对象。为<strong>不同类型的无序键值对集合</strong></li><li>数组<br>包括简单值、对象、数组。为<strong>相同类型的有序数据集合</strong></li></ol><h3 id="JSON对象的构成方式"><a href="#JSON对象的构成方式" class="headerlink" title="JSON对象的构成方式"></a>JSON对象的构成方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;Jonathan&quot;,</span><br><span class="line">    &quot;age&quot;:23,</span><br><span class="line">    &quot;job&quot;:&quot;developer&quot;,</span><br><span class="line">    &quot;school&quot;: &#123;</span><br><span class="line">        &quot;schName&quot;:&quot;CDUT&quot;,</span><br><span class="line">        &quot;location&quot;: &quot;Chenghua CD&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要点：</p><ol><li>没有声明变量（不用在前面加var）</li><li>没有末尾的分号</li><li>对象的属性与属性名<strong>必须加双引号</strong></li></ol><h3 id="JSON数组的构成方式"><a href="#JSON数组的构成方式" class="headerlink" title="JSON数组的构成方式"></a>JSON数组的构成方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">    &quot;age&quot;: 24,</span><br><span class="line">    &quot;job&quot;: &quot;writer&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Bob&quot;,</span><br><span class="line">    &quot;age&quot;: 21,</span><br><span class="line">    &quot;job&quot;: &quot;student&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;:&quot;Jonathan&quot;,</span><br><span class="line">    &quot;age&quot;:23,</span><br><span class="line">    &quot;job&quot;:&quot;developer&quot;,</span><br><span class="line">    &quot;school&quot;: &#123;</span><br><span class="line">        &quot;schName&quot;:&quot;CDUT&quot;,</span><br><span class="line">        &quot;location&quot;: &quot;Chenghua CD&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>要点：</p><ol><li>整个数组用[]包裹</li><li>各元素用逗号,隔开</li><li>对象表示法同上</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSON是什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;JSON是一种&lt;strong&gt;数据格式&lt;/strong&gt;，不是一种编程语言。&lt;/li&gt;
&lt;li&gt;JSON&lt;strong&gt;不属于Javascript&lt;/strong&gt;，尽管有相同的语法形式&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="JSON" scheme="https://jumper3.github.io/blog/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>HTML语义化</title>
    <link href="https://jumper3.github.io/blog/2017/08/28/HTML%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>https://jumper3.github.io/blog/2017/08/28/HTML语义化/</id>
    <published>2017-08-28T09:17:00.000Z</published>
    <updated>2018-01-02T02:46:43.122Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何为HTML语义化"><a href="#何为HTML语义化" class="headerlink" title="何为HTML语义化"></a>何为HTML语义化</h3><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。</p><h3 id="为什么要语义化？"><a href="#为什么要语义化？" class="headerlink" title="为什么要语义化？"></a>为什么要语义化？</h3><ul><li>有利于SEO（搜索引擎优化），有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重。</li><li>语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构</li><li>方便其他设备的解析</li><li>便于团队开发和维护</li></ul><h3 id="应该注意什么？"><a href="#应该注意什么？" class="headerlink" title="应该注意什么？"></a>应该注意什么？</h3><ul><li>尽可能少的使用无语义的标签div和span；</li><li>在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li><li>不要使用纯样式标签，如：b、font、u等，改用css设置。</li><li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li><li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li><li>表单域要用fieldset标签包起来，并用legend标签说明表单的用途；</li><li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;何为HTML语义化&quot;&gt;&lt;a href=&quot;#何为HTML语义化&quot; class=&quot;headerlink&quot; title=&quot;何为HTML语义化&quot;&gt;&lt;/a&gt;何为HTML语义化&lt;/h3&gt;&lt;p&gt;语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://jumper3.github.io/blog/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>形参和实参</title>
    <link href="https://jumper3.github.io/blog/2017/08/28/%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82/"/>
    <id>https://jumper3.github.io/blog/2017/08/28/形参和实参/</id>
    <published>2017-08-28T09:07:59.000Z</published>
    <updated>2018-01-02T02:46:10.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实参-argument-："><a href="#实参-argument-：" class="headerlink" title="实参(argument)："></a>实参(argument)：</h3><blockquote><p>全称为”实际参数”是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都<strong>必须具有确定的值</strong>， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。      </p></blockquote><h3 id="形参-parameter-："><a href="#形参-parameter-：" class="headerlink" title="形参(parameter)："></a>形参(parameter)：</h3><blockquote><p>全称为”形式参数” 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来<strong>接收调用该函数时传入的参数</strong>.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。</p></blockquote><h3 id="形参和实参的区别"><a href="#形参和实参的区别" class="headerlink" title="形参和实参的区别"></a>形参和实参的区别</h3><p>形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。 实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 </p><p>形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。</p><ol><li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。 </li><li>实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。 </li><li>实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。 </li><li>函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</li><li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</li></ol><p>而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就是实参本身。所以在函数体内部可以改变实参的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实参-argument-：&quot;&gt;&lt;a href=&quot;#实参-argument-：&quot; class=&quot;headerlink&quot; title=&quot;实参(argument)：&quot;&gt;&lt;/a&gt;实参(argument)：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;全称为”实际参数”是在调用
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://jumper3.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
</feed>
