{"meta":{"title":"冷吃兔","subtitle":"大家好，我是来自自贡的冷吃兔，我给大家表演一个吐粘痰","description":"个人技术博客","author":"Jonathan","url":"https://jumper3.github.io/blog"},"pages":[],"posts":[{"title":"百词斩三个月小记","slug":"百词斩三个月","date":"2017-12-26T08:07:59.000Z","updated":"2017-12-27T09:01:24.859Z","comments":true,"path":"2017/12/26/百词斩三个月/","link":"","permalink":"https://jumper3.github.io/blog/2017/12/26/百词斩三个月/","excerpt":"","text":"三个月期间做过哪些项目 系统思维课-视频中心 系统思维课-小书单 百词斩阅读者-阅读者 ​ 使用过哪些技术视频中心 技术 用途 Tornado 利用模版功能渲染页面 Redis 用户信息的key-value储存 Bootstrap 标题栏、按钮、分页Tab Swiper 首页轮播图，支持触控，为移动设备优化 Google Analytics 网站流量分析、用户统计 Terminal Linux常用指令、SSH 小书单 技术 用途 Tornado 小程序后端框架 MySQL 小程序主力数据库 小程序API 完成小程序的数据处理及交互 小程序框架 类Vue的MVVM框架，用于模版渲染 ES6 使用了迭代器、模块化、块级绑定、字符串模版等新特性 阅读者 技术 用途 Vue.js 阅读者前端框架、组件化 Vue-router 页面路由 Animated.css 通过第三方CSS库优化交互 axios AJAX jQuery 项目初期用DOM思想快速开发 Less 嵌套语法，scope作用域 Node.js-Express 亮哥主后端，我辅助，顺便了解promise 杂项Vscode、Bitbuckets(Git)、Zeplin（一款原型制作软件，方便抠图） 项目简介1.视频中心视频中心位于“斩家”公众号内，内容包括百词斩内部课程系统思维课的课程视频、公司内部视频分享及课程小摘要三个栏目 2.小书单3.阅读者遇见过哪些糟心的事 / 都是怎么解决的1.Python字符串编码问题2. JSON的保留字符3.PDF在网页上的显示","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://jumper3.github.io/blog/tags/前端/"}]},{"title":"删除数组中的指定元素","slug":"删除数组中的指定元素","date":"2017-12-02T10:17:00.000Z","updated":"2017-12-27T02:55:04.221Z","comments":true,"path":"2017/12/02/删除数组中的指定元素/","link":"","permalink":"https://jumper3.github.io/blog/2017/12/02/删除数组中的指定元素/","excerpt":"","text":"JavaScript的数组中默认不支持删除指定元素的操作，如12let book_id = [1,2,3,4]book_id.delete(4) //错误，JS数组没有该方法 因此，解决的办法有 使用集合SetES6中新加入了集合类型Set()，因为集合本身支持add(),delete(),remove()，forEach()等操作，因此可以直接将Array()转化为Set()123let book_id = new Set([1,2,3,4])book_id.delete(4)console.log(book_id) //Set &#123; 1, 2, 3 &#125; 但要注意到，Set()本身的限制 Set是一种无重复值的有序列表，允许对它包含的数据进行快速访问，从而增加了一个追踪离散值的更有效方式 因此，如果本身要操作的数据不符合Set()的要求，则要用到ES5原生方法 使用indexOf()其实是通过indexOf()找到要删除元素在数组中的索引，然后用splice()删除1234let book_name = [&apos;1984&apos;,&apos;动物庄园&apos;,&apos;乌合之众&apos;]let i = book_name.indexOf(&apos;动物庄园&apos;)book_name.splice(i,1)console.log(book_name) //[ &apos;1984&apos;, &apos;乌合之众&apos; ] 搞定！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jumper3.github.io/blog/tags/JavaScript/"}]},{"title":"JavaScript对象的深入理解 （二）","slug":"JS对象的深入理解（二）","date":"2017-11-02T09:17:00.000Z","updated":"2017-12-26T09:19:38.171Z","comments":true,"path":"2017/11/02/JS对象的深入理解（二）/","link":"","permalink":"https://jumper3.github.io/blog/2017/11/02/JS对象的深入理解（二）/","excerpt":"","text":"之前提到，构造函数方法创建对象存在着方法不共享的问题，因此引申出了原型模式创建对象 原型模式 原型模式旨在创建一个模版对象，该对象的所有属性和方法被其实例所共享。 原型的概念不同于构造函数模式创建对象只能单级即成，得益于原型链的概念，原型模式可实现类似其他OOP语言的多级继承。 原型链：一系列有继承关系的函数（对象）中[[prototype]]属性自底向上的指向 先给一个例子： 12345678910111213141516function Person() &#123; &#125;Person.prototype = &#123; constructor: Person, name: \"Jonathan\", age: 23, job: developer, sayName: function() &#123; console.log(this.name); &#125;&#125;person1 = new Person();person2 = new Person(); 该例子中各对象的关系如下 // 每一个函数（对象）都可以视为一个模版，向上看，该对象的[[prototype]] 创建原型对象1234567891011121314151617181920function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: \"Jonathan\", age: 23, job: developer, sayName: function() &#123; console.log(this.name); &#125;&#125;var person1 = new Person();person1.sayName(); //\"Jonathan\"var person2 = new Person();person2.sayName(); //\"Jonathan\"console.log(person1.sayName == person2.sayName); //true 要点 先命名一个空函数 用对象字面量方式，为该函数的.prototype属性添加原型属性及方法 为了constructor属性的正确指向，应先把constructor指向该对象 原型对象的问题由于众多实例共享原型的属性，因此改变其中某个实例的属性会影响到全局，造成属性污染，例子如下： 12345678910111213141516171819202122function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", friends : [\"Shelby\", \"Court\"], sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Court,Van\"alert(person2.friends); //\"Shelby,Court,Van\"alert(person1.friends === person2.friends); //true 可见，person1的friends属性污染了person2的friends属性。为避免这种情况，引入组合构造函数与原型模式。 组合使用构造函数与原型模式单一使用原型对象的问题在于所有属性皆共享，若不想共享某属性，则可放入构造函数中。 1234567891011121314151617181920212223function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Boy next door\", \"Deep dark fantasy\"];&#125;Person.prototype = &#123; constructor: Person, sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\");person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Court,Van\"alert(person2.friends); //\"Shelby,Court\"alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jumper3.github.io/blog/tags/JavaScript/"}]},{"title":"关于排序问题的思考","slug":"关于排序问题的思考","date":"2017-09-20T09:07:59.000Z","updated":"2017-12-27T03:12:01.853Z","comments":true,"path":"2017/09/20/关于排序问题的思考/","link":"","permalink":"https://jumper3.github.io/blog/2017/09/20/关于排序问题的思考/","excerpt":"","text":"今天去面试，被问到了以下问题： 从1000个正整数中找出最大的五个数 我的解法思路：先生成一个含1000个数的随机数组Arr1，然后建立一个空数组Arr2，及一个变量max=0。然后遍历Arr1，其中大于max的数存入数组2。便利过后，得到递增数组Arr2。用slice方法取Arr2后五位即为最大五位。 var Arr1 = []; for (var i = 0; i&lt;1000; i++){ Arr1[i] = Math.floor(Math.random()*1000+1); }; //先生成1000个正整数 var Arr2 = new Array(); var max = 0; for (var i = 0; i&lt;1000; i++){ if (Arr1[i]&gt;max){ Arr2.push(Arr1[i]); max = Arr1[i]; } }; var result = Arr2.slice[-5]; console.log(result); 运行结果如下： 1(5) [982,985,993,996,998] 这个算法看似能找出最大数，但是存在以下问题：当Arr1为[100,999,…,1]这样的递减数列时，只能找出第一个最大数，无法将Arr2凑满。而且，面试官还问到了时间复杂度的问题，当时我并没有概念。 问题分析为妥善解决问题，还是将Arr1数组从小到大重新排列，这样就不会受到原数据中大小次序影响。因此可以采用算法学中的排序方法，如冒泡排序、选择排序、插入排序等。 概念解释算法复杂度的概念（包括时间复杂度和空间复杂度）： http://blog.csdn.net/booirror/article/details/7707551/http://www.jianshu.com/p/99bac69fdd97 排序算法的Javascript实现： https://github.com/damonare/Sorts 解法优化之前解法的时间复杂度为O(n)。现在采用更稳妥的，可排序的冒泡排序算法，时间复杂度为O(n*n)。代码实现如下： var Arr1 = []; for (var i = 0; i&lt;1000; i++){ Arr1[i] = Math.floor(Math.random()*1000+1); }; function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len; i++) { for (var j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } var Arr2 = bubbleSort(Arr1); var result = Arr2.slice(-5); console.log(result); 代码运行截图： 1(5) [998,999,999,1000,1000] 最后显然，实现了目的，但是算法上还可以采用时间复杂度更低的算法。 怎样才能找到尽可能优的解法呢？ 且听下回分解","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jumper3.github.io/blog/tags/算法/"}]},{"title":"JavaScript对象的深入理解 （一）","slug":"JS对象的深入理解（一）","date":"2017-09-19T09:07:59.000Z","updated":"2017-12-26T09:19:24.501Z","comments":true,"path":"2017/09/19/JS对象的深入理解（一）/","link":"","permalink":"https://jumper3.github.io/blog/2017/09/19/JS对象的深入理解（一）/","excerpt":"","text":"对象，一种数据类型。对象是属性(变量)和方法(函数)结合在一起的数据实体 对象的出现，就是为了解决封装的问题。可以将许多属性与方法封装在一个对象里，方便调用，也符合人的思考方式。 JavaScript中创建对象的基本方法 创建Object实例，再添加属性和方法 1234567var person = new Object(); person.name = &quot;Jonathan&quot;; person.age = 23; person.job = &quot;Developer&quot;; person.sayName = function () &#123; console.log(this.name);&#125;; 对象字面量方法由于上述写法繁琐，故出现了对象字面量方法创建对象。 1234567891011var person = &#123; name: &quot;Jonathan&quot;, age: 23, job: &quot;Developer&quot;, sayName: function () &#123; console.log(this.name); &#125;&#125;;console.log(person.name); //Jonathanperson.sayName(); //Jonathan 这样一来，就把属性和方法封装进了一个对象中，方便调用。 构造函数模式如果要创建许多对象，传统方法存在以下问题 对象名太多，容易搞重复 新建一个对象就要全部重写属性和方法，过于复杂 无法发挥JavaScript的面向对象优势（继承） 由于JavaScript本身没有类的概念，因此诞生了构造函数模式来创建对象，该方法利用函数创建对象。由于函数本身也是对象，因此可以这么操作。构造函数创建对象的方法是：1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;; &#125; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 要点： 构造函数命名应以大写字母开头（约定俗成的规矩） 构造函数本身也是函数，只不过是用来创建对象的 要创建对象的实例，必须要用new操作符，否则跟调用函数无异。 任何函数，只要通过new操作符来调用，它就可以作为构造函数。 至此，一个Person对象的创建就完成了，它有以下优点： 新建对象只用给函数提供参数，简化了创建。 有了实例的概念，如Person1就是Person的实例。无形之中给对象归了类。 更好的体现了封装，创建对象只用给参数，不用关心对象内部细节。 但用构造函数模式的方法创建对象并不是完美的，它存在以下问题，即：每个方法（对象内置函数）都要在实例上重新创建一遍构造函数也可以用以下方法定义，方便我们发现问题 123456789101112function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = new Function(console.log(this.name)); &#125;; &#125; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);console.log(person1.sayName == person2sayName); //false 在新建对象person1和person2时，分别新建了两个不同的方法person1.sayName()和person2.sayName()。但这很没有必要，只需要公用一个sayName()方法就好了。为了解决上述问题，诞生了原型模式","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jumper3.github.io/blog/tags/JavaScript/"}]},{"title":"JSON初探","slug":"JSON初探","date":"2017-09-09T04:00:00.000Z","updated":"2017-12-26T09:25:50.391Z","comments":true,"path":"2017/09/09/JSON初探/","link":"","permalink":"https://jumper3.github.io/blog/2017/09/09/JSON初探/","excerpt":"","text":"JSON是什么？ JSON是一种数据格式，不是一种编程语言。 JSON不属于Javascript，尽管有相同的语法形式 并不只是Javascript，很多语言都可以使用JSON交换数据 JSON的语法JSON可以表示的值 简单值包括字符串、数值、布尔值、null 对象包括简单值或对象。为不同类型的无序键值对集合 数组包括简单值、对象、数组。为相同类型的有序数据集合 JSON对象的构成方式123456789&#123; &quot;name&quot;:&quot;Jonathan&quot;, &quot;age&quot;:23, &quot;job&quot;:&quot;developer&quot;, &quot;school&quot;: &#123; &quot;schName&quot;:&quot;CDUT&quot;, &quot;location&quot;: &quot;Chenghua CD&quot; &#125;&#125; 要点： 没有声明变量（不用在前面加var） 没有末尾的分号 对象的属性与属性名必须加双引号 JSON数组的构成方式123456789101112131415161718192021[ &#123; &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 24, &quot;job&quot;: &quot;writer&quot; &#125;, &#123; &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 21, &quot;job&quot;: &quot;student&quot; &#125;, &#123; &quot;name&quot;:&quot;Jonathan&quot;, &quot;age&quot;:23, &quot;job&quot;:&quot;developer&quot;, &quot;school&quot;: &#123; &quot;schName&quot;:&quot;CDUT&quot;, &quot;location&quot;: &quot;Chenghua CD&quot; &#125; &#125;] 要点： 整个数组用[]包裹 各元素用逗号,隔开 对象表示法同上","categories":[],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://jumper3.github.io/blog/tags/JSON/"}]},{"title":"HTML语义化","slug":"HTML语义化","date":"2017-08-28T09:17:00.000Z","updated":"2018-01-02T02:46:43.122Z","comments":true,"path":"2017/08/28/HTML语义化/","link":"","permalink":"https://jumper3.github.io/blog/2017/08/28/HTML语义化/","excerpt":"","text":"何为HTML语义化语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。 为什么要语义化？ 有利于SEO（搜索引擎优化），有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重。 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构 方便其他设备的解析 便于团队开发和维护 应该注意什么？ 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jumper3.github.io/blog/tags/HTML/"}]},{"title":"形参和实参","slug":"形参和实参","date":"2017-08-28T09:07:59.000Z","updated":"2018-01-02T02:46:10.942Z","comments":true,"path":"2017/08/28/形参和实参/","link":"","permalink":"https://jumper3.github.io/blog/2017/08/28/形参和实参/","excerpt":"","text":"实参(argument)： 全称为”实际参数”是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。 形参(parameter)： 全称为”形式参数” 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。 形参和实参的区别形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。 实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。 而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就是实参本身。所以在函数体内部可以改变实参的值。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jumper3.github.io/blog/tags/JavaScript/"}]}]}