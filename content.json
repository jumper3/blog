{"meta":{"title":"山哥的地盘","subtitle":null,"description":"个人技术博客","author":"Jonathan","url":"https://jumper3.github.io/blog"},"pages":[],"posts":[{"title":"JavaScript对象的深入理解 （二）","slug":"JS对象的深入理解（二）","date":"2017-12-26T09:17:00.000Z","updated":"2017-12-26T09:17:06.832Z","comments":true,"path":"2017/12/26/JS对象的深入理解（二）/","link":"","permalink":"https://jumper3.github.io/blog/2017/12/26/JS对象的深入理解（二）/","excerpt":"","text":"之前提到，构造函数方法创建对象存在着方法不共享的问题，因此引申出了原型模式创建对象 原型模式 原型模式旨在创建一个模版对象，该对象的所有属性和方法被其实例所共享。 原型的概念不同于构造函数模式创建对象只能单级即成，得益于原型链的概念，原型模式可实现类似其他OOP语言的多级继承。 原型链：一系列有继承关系的函数（对象）中[[prototype]]属性自底向上的指向 先给一个例子： 12345678910111213141516function Person() &#123; &#125;Person.prototype = &#123; constructor: Person, name: \"Jonathan\", age: 23, job: developer, sayName: function() &#123; console.log(this.name); &#125;&#125;person1 = new Person();person2 = new Person(); 该例子中各对象的关系如下 // 每一个函数（对象）都可以视为一个模版，向上看，该对象的[[prototype]] 创建原型对象1234567891011121314151617181920function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: \"Jonathan\", age: 23, job: developer, sayName: function() &#123; console.log(this.name); &#125;&#125;var person1 = new Person();person1.sayName(); //\"Jonathan\"var person2 = new Person();person2.sayName(); //\"Jonathan\"console.log(person1.sayName == person2.sayName); //true 要点 先命名一个空函数 用对象字面量方式，为该函数的.prototype属性添加原型属性及方法 为了constructor属性的正确指向，应先把constructor指向该对象 原型对象的问题由于众多实例共享原型的属性，因此改变其中某个实例的属性会影响到全局，造成属性污染，例子如下： 12345678910111213141516171819202122function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", friends : [\"Shelby\", \"Court\"], sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Court,Van\"alert(person2.friends); //\"Shelby,Court,Van\"alert(person1.friends === person2.friends); //true 可见，person1的friends属性污染了person2的friends属性。为避免这种情况，引入组合构造函数与原型模式。 组合使用构造函数与原型模式单一使用原型对象的问题在于所有属性皆共享，若不想共享某属性，则可放入构造函数中。 1234567891011121314151617181920212223function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Boy next door\", \"Deep dark fantasy\"];&#125;Person.prototype = &#123; constructor: Person, sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\");person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Court,Van\"alert(person2.friends); //\"Shelby,Court\"alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jumper3.github.io/blog/tags/JavaScript/"}]},{"title":"JavaScript对象的深入理解 （一）","slug":"JS对象的深入理解（一）","date":"2017-12-26T09:07:59.000Z","updated":"2017-12-26T09:15:10.191Z","comments":true,"path":"2017/12/26/JS对象的深入理解（一）/","link":"","permalink":"https://jumper3.github.io/blog/2017/12/26/JS对象的深入理解（一）/","excerpt":"","text":"对象，一种数据类型。对象是属性(变量)和方法(函数)结合在一起的数据实体 对象的出现，就是为了解决封装的问题。可以将许多属性与方法封装在一个对象里，方便调用，也符合人的思考方式。 JavaScript中创建对象的基本方法 创建Object实例，再添加属性和方法 1234567var person = new Object(); person.name = &quot;Jonathan&quot;; person.age = 23; person.job = &quot;Developer&quot;; person.sayName = function () &#123; console.log(this.name);&#125;; 对象字面量方法由于上述写法繁琐，故出现了对象字面量方法创建对象。 1234567891011var person = &#123; name: &quot;Jonathan&quot;, age: 23, job: &quot;Developer&quot;, sayName: function () &#123; console.log(this.name); &#125;&#125;;console.log(person.name); //Jonathanperson.sayName(); //Jonathan 这样一来，就把属性和方法封装进了一个对象中，方便调用。 构造函数模式如果要创建许多对象，传统方法存在以下问题 对象名太多，容易搞重复 新建一个对象就要全部重写属性和方法，过于复杂 无法发挥JavaScript的面向对象优势（继承） 由于JavaScript本身没有类的概念，因此诞生了构造函数模式来创建对象，该方法利用函数创建对象。由于函数本身也是对象，因此可以这么操作。构造函数创建对象的方法是：1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;; &#125; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 要点： 构造函数命名应以大写字母开头（约定俗成的规矩） 构造函数本身也是函数，只不过是用来创建对象的 要创建对象的实例，必须要用new操作符，否则跟调用函数无异。 任何函数，只要通过new操作符来调用，它就可以作为构造函数。 至此，一个Person对象的创建就完成了，它有以下优点： 新建对象只用给函数提供参数，简化了创建。 有了实例的概念，如Person1就是Person的实例。无形之中给对象归了类。 更好的体现了封装，创建对象只用给参数，不用关心对象内部细节。 但用构造函数模式的方法创建对象并不是完美的，它存在以下问题，即：每个方法（对象内置函数）都要在实例上重新创建一遍构造函数也可以用以下方法定义，方便我们发现问题 123456789101112function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = new Function(console.log(this.name)); &#125;; &#125; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);console.log(person1.sayName == person2sayName); //false 在新建对象person1和person2时，分别新建了两个不同的方法person1.sayName()和person2.sayName()。但这很没有必要，只需要公用一个sayName()方法就好了。为了解决上述问题，诞生了原型模式","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jumper3.github.io/blog/tags/JavaScript/"}]},{"title":"百词斩三个月小记","slug":"百词斩三个月","date":"2017-12-26T08:07:59.000Z","updated":"2017-12-26T09:06:07.576Z","comments":true,"path":"2017/12/26/百词斩三个月/","link":"","permalink":"https://jumper3.github.io/blog/2017/12/26/百词斩三个月/","excerpt":"","text":"三个月期间做过哪些项目 系统思维课-视频中心 系统思维课-小书单 百词斩阅读者-阅读者 ​ 使用过哪些技术视频中心 技术 用途 Tornado 利用模版功能渲染页面 Redis 用户信息的key-value储存 Bootstrap 标题栏、按钮 Swiper 首页轮播图，支持触控，为移动设备优化 Google Analytics 网站流量分析、用户统计 Terminal Linux常用指令、SSH 小书单 技术 用途 Tornado 小程序后端框架 MySQL 小程序主力数据库 小程序API 完成小程序的数据处理及交互 小程序框架 类Vue的MVVM框架，用于模版渲染 ES6 使用了迭代器、模块化、块级绑定、字符串模版等新特性 阅读者 技术 用途 Vue.js 阅读者前端框架、组件化 Vue-router 页面路由 Animated.css 通过第三方CSS库优化交互 axios AJAX jQuery 项目初期用DOM思想快速开发 Less 嵌套语法，scope作用域 Node.js-Express 亮哥主后端，我辅助，顺便了解promise 杂项Vscode、Bitbuckets(Git)","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://jumper3.github.io/blog/tags/前端/"}]}]}